{"version":3,"sources":["css-layout.js"],"names":["root","factory","define","amd","exports","module","computeLayout","this","fillNodes","node","layout","isDirty","width","undefined","height","top","left","right","bottom","style","children","measure","length","Error","forEach","isUndefined","value","Number","isNaN","isRowDirection","flexDirection","CSS_FLEX_DIRECTION_ROW","CSS_FLEX_DIRECTION_ROW_REVERSE","isColumnDirection","CSS_FLEX_DIRECTION_COLUMN","CSS_FLEX_DIRECTION_COLUMN_REVERSE","getFlex","flex","isFlexBasisAuto","POSITIVE_FLEX_IS_AUTO","getFlexGrowFactor","getFlexShrinkFactor","getLeadingMargin","axis","marginStart","marginLeft","marginRight","marginTop","marginBottom","margin","getTrailingMargin","marginEnd","getLeadingPadding","paddingStart","paddingLeft","paddingRight","paddingTop","paddingBottom","padding","getTrailingPadding","paddingEnd","getLeadingBorder","borderStartWidth","borderLeftWidth","borderRightWidth","borderTopWidth","borderBottomWidth","borderWidth","getTrailingBorder","borderEndWidth","getLeadingPaddingAndBorder","getTrailingPaddingAndBorder","getMarginAxis","getPaddingAndBorderAxis","getJustifyContent","justifyContent","getAlignContent","alignContent","getAlignItem","child","alignSelf","alignItems","resolveAxis","direction","CSS_DIRECTION_RTL","resolveDirection","parentDirection","CSS_DIRECTION_INHERIT","CSS_DIRECTION_LTR","getFlexDirection","getCrossFlexDirection","getPositionType","position","CSS_POSITION_RELATIVE","getOverflow","overflow","CSS_OVERFLOW_VISIBLE","isFlex","isFlexWrap","flexWrap","getDimWithMargin","measuredDim","isStyleDimDefined","dim","isLayoutDimDefined","isLeadingPosDefined","CSS_START","leading","isTrailingPosDefined","CSS_END","trailing","isMeasureDefined","getLeadingPosition","getTrailingPosition","boundAxisWithinMinAndMax","min","row","minWidth","row-reverse","column","minHeight","column-reverse","max","maxWidth","maxHeight","boundValue","fminf","a","b","fmaxf","boundAxis","setTrailingPosition","size","pos","getRelativePosition","setPosition","mainAxis","crossAxis","assert","condition","message","layoutNodeImpl","availableWidth","availableHeight","widthMeasureMode","heightMeasureMode","performLayout","CSS_MEASURE_MODE_UNDEFINED","paddingAndBorderAxisRow","paddingAndBorderAxisColumn","marginAxisRow","marginAxisColumn","innerWidth","innerHeight","CSS_MEASURE_MODE_EXACTLY","measuredWidth","measuredHeight","measureDim","CSS_MEASURE_MODE_AT_MOST","childCount","i","childWidth","childHeight","childWidthMeasureMode","childHeightMeasureMode","isMainAxisRow","isNodeFlexWrap","firstAbsoluteChild","currentAbsoluteChild","leadingPaddingAndBorderMain","trailingPaddingAndBorderMain","leadingPaddingAndBorderCross","paddingAndBorderAxisMain","paddingAndBorderAxisCross","measureModeMainDim","measureModeCrossDim","availableInnerWidth","availableInnerHeight","availableInnerMainDim","availableInnerCrossDim","childDirection","CSS_POSITION_ABSOLUTE","nextChild","flexBasis","CSS_UNDEFINED","CSS_OVERFLOW_HIDDEN","CSS_ALIGN_STRETCH","layoutNodeInternal","startOfLineIndex","endOfLineIndex","lineCount","totalLineCrossDim","maxLineMainDim","itemsOnLine","sizeConsumedOnCurrentLine","totalFlexGrowFactors","totalFlexShrinkScaledFactors","firstRelativeChild","currentRelativeChild","lineIndex","outerFlexBasis","canSkipFlex","leadingMainDim","betweenMainDim","remainingFreeSpace","originalRemainingFreeSpace","deltaFreeSpace","childFlexBasis","flexShrinkScaledFactor","flexGrowFactor","baseMainSize","boundMainSize","deltaFlexShrinkScaledFactors","deltaFlexGrowFactors","updatedMainSize","requiresStretchLayout","CSS_JUSTIFY_FLEX_START","CSS_JUSTIFY_CENTER","CSS_JUSTIFY_FLEX_END","CSS_JUSTIFY_SPACE_BETWEEN","CSS_JUSTIFY_SPACE_AROUND","mainDim","crossDim","containerCrossAxis","leadingCrossDim","alignItem","isCrossSizeDefinite","CSS_ALIGN_FLEX_START","remainingCrossDim","CSS_ALIGN_CENTER","remainingAlignContentDim","crossDimLead","currentLead","CSS_ALIGN_FLEX_END","endIndex","j","startIndex","lineHeight","alignContentAlignItem","needsMainTrailingPos","needsCrossTrailingPos","canUseCachedMeasurement","isTextNode","marginRow","marginColumn","cachedLayout","isHeightSame","isWidthSame","isHeightValid","computedHeight","isWidthValid","computedWidth","reason","needToVisitNode","generationCount","gCurrentGenerationCount","lastParentDirection","cachedMeasurements","len","cachedResults","newCacheEntry","push","measureWidth","measureHeight","shouldUpdate","layoutNode"],"mappings":"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","file":"css-layout.min.js","sourcesContent":["// UMD (Universal Module Definition)\n// See https://github.com/umdjs/umd for reference\n//\n// This file uses the following specific UMD implementation:\n// https://github.com/umdjs/umd/blob/master/templates/returnExports.js\n(function(root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    // AMD. Register as an anonymous module.\n    define([], factory);\n  } else if (typeof exports === 'object') {\n    // Node. Does not work with strict CommonJS, but\n    // only CommonJS-like environments that support module.exports,\n    // like Node.\n    module.exports = factory();\n  } else {\n    // Browser globals (root is window)\n    root.computeLayout = factory();\n  }\n}(this, function() {\n    /**\n * Copyright (c) 2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\nvar computeLayout = (function() {\n\n  var POSITIVE_FLEX_IS_AUTO = false;\n\n  var gCurrentGenerationCount = 0;\n\n  var CSS_UNDEFINED;\n\n  var CSS_LEFT = 'left';\n  var CSS_TOP = 'top';\n  var CSS_RIGHT = 'right';\n  var CSS_BOTTOM = 'bottom';\n  var CSS_START = 'start';\n  var CSS_END = 'end';\n\n  var CSS_DIRECTION_INHERIT = 'inherit';\n  var CSS_DIRECTION_LTR = 'ltr';\n  var CSS_DIRECTION_RTL = 'rtl';\n\n  var CSS_FLEX_DIRECTION_ROW = 'row';\n  var CSS_FLEX_DIRECTION_ROW_REVERSE = 'row-reverse';\n  var CSS_FLEX_DIRECTION_COLUMN = 'column';\n  var CSS_FLEX_DIRECTION_COLUMN_REVERSE = 'column-reverse';\n\n  var CSS_JUSTIFY_FLEX_START = 'flex-start';\n  var CSS_JUSTIFY_CENTER = 'center';\n  var CSS_JUSTIFY_FLEX_END = 'flex-end';\n  var CSS_JUSTIFY_SPACE_BETWEEN = 'space-between';\n  var CSS_JUSTIFY_SPACE_AROUND = 'space-around';\n\n  var CSS_ALIGN_FLEX_START = 'flex-start';\n  var CSS_ALIGN_CENTER = 'center';\n  var CSS_ALIGN_FLEX_END = 'flex-end';\n  var CSS_ALIGN_STRETCH = 'stretch';\n\n  var CSS_POSITION_RELATIVE = 'relative';\n  var CSS_POSITION_ABSOLUTE = 'absolute';\n\n  var CSS_OVERFLOW_VISIBLE = 'visible';\n  var CSS_OVERFLOW_HIDDEN = 'hidden';\n\n  var CSS_MEASURE_MODE_UNDEFINED = 'undefined';\n  var CSS_MEASURE_MODE_EXACTLY = 'exactly';\n  var CSS_MEASURE_MODE_AT_MOST = 'at-most';\n\n  var leading = {\n    'row': 'left',\n    'row-reverse': 'right',\n    'column': 'top',\n    'column-reverse': 'bottom'\n  };\n  var trailing = {\n    'row': 'right',\n    'row-reverse': 'left',\n    'column': 'bottom',\n    'column-reverse': 'top'\n  };\n  var pos = {\n    'row': 'left',\n    'row-reverse': 'right',\n    'column': 'top',\n    'column-reverse': 'bottom'\n  };\n  var dim = {\n    'row': 'width',\n    'row-reverse': 'width',\n    'column': 'height',\n    'column-reverse': 'height'\n  };\n  var measuredDim = {\n    'row': 'measuredWidth',\n    'row-reverse': 'measuredWidth',\n    'column': 'measuredHeight',\n    'column-reverse': 'measuredHeight'\n  };\n\n  // When transpiled to Java / C the node type has layout, children and style\n  // properties. For the JavaScript version this function adds these properties\n  // if they don't already exist.\n  function fillNodes(node) {\n    if (!node.layout || node.isDirty) {\n      node.layout = {\n        width: undefined,\n        height: undefined,\n        top: 0,\n        left: 0,\n        right: 0,\n        bottom: 0\n      };\n    }\n\n    if (!node.style) {\n      node.style = {};\n    }\n\n    if (!node.children) {\n      node.children = [];\n    }\n\n    if (node.style.measure && node.children && node.children.length) {\n      throw new Error('Using custom measure function is supported only for leaf nodes.');\n    }\n\n    node.children.forEach(fillNodes);\n    return node;\n  }\n\n  function isUndefined(value) {\n    return value === undefined || Number.isNaN(value);\n  }\n\n  function isRowDirection(flexDirection) {\n    return flexDirection === CSS_FLEX_DIRECTION_ROW ||\n           flexDirection === CSS_FLEX_DIRECTION_ROW_REVERSE;\n  }\n\n  function isColumnDirection(flexDirection) {\n    return flexDirection === CSS_FLEX_DIRECTION_COLUMN ||\n           flexDirection === CSS_FLEX_DIRECTION_COLUMN_REVERSE;\n  }\n\n  function getFlex(node) {\n    if (node.style.flex === undefined) {\n      return 0;\n    }\n    return node.style.flex;\n  }\n\n  function isFlexBasisAuto(node) {\n    if (POSITIVE_FLEX_IS_AUTO) {\n      // All flex values are auto.\n      return true;\n    } else {\n      // A flex value > 0 implies a basis of zero.\n      return getFlex(node) <= 0;\n    }\n  }\n\n  function getFlexGrowFactor(node) {\n    // Flex grow is implied by positive values for flex.\n    if (getFlex(node) > 0) {\n      return getFlex(node);\n    }\n    return 0;\n  }\n\n  function getFlexShrinkFactor(node) {\n    if (POSITIVE_FLEX_IS_AUTO) {\n      // A flex shrink factor of 1 is implied by non-zero values for flex.\n      if (getFlex(node) !== 0) {\n        return 1;\n      }\n    } else {\n      // A flex shrink factor of 1 is implied by negative values for flex.\n      if (getFlex(node) < 0) {\n        return 1;\n      }\n    }\n    return 0;\n  }\n\n  function getLeadingMargin(node, axis) {\n    if (node.style.marginStart !== undefined && isRowDirection(axis)) {\n      return node.style.marginStart;\n    }\n\n    var value = null;\n    switch (axis) {\n      case 'row':            value = node.style.marginLeft;   break;\n      case 'row-reverse':    value = node.style.marginRight;  break;\n      case 'column':         value = node.style.marginTop;    break;\n      case 'column-reverse': value = node.style.marginBottom; break;\n    }\n\n    if (value !== undefined) {\n      return value;\n    }\n\n    if (node.style.margin !== undefined) {\n      return node.style.margin;\n    }\n\n    return 0;\n  }\n\n  function getTrailingMargin(node, axis) {\n    if (node.style.marginEnd !== undefined && isRowDirection(axis)) {\n      return node.style.marginEnd;\n    }\n\n    var value = null;\n    switch (axis) {\n      case 'row':            value = node.style.marginRight;  break;\n      case 'row-reverse':    value = node.style.marginLeft;   break;\n      case 'column':         value = node.style.marginBottom; break;\n      case 'column-reverse': value = node.style.marginTop;    break;\n    }\n\n    if (value != null) {\n      return value;\n    }\n\n    if (node.style.margin !== undefined) {\n      return node.style.margin;\n    }\n\n    return 0;\n  }\n\n  function getLeadingPadding(node, axis) {\n    if (node.style.paddingStart !== undefined && node.style.paddingStart >= 0\n        && isRowDirection(axis)) {\n      return node.style.paddingStart;\n    }\n\n    var value = null;\n    switch (axis) {\n      case 'row':            value = node.style.paddingLeft;   break;\n      case 'row-reverse':    value = node.style.paddingRight;  break;\n      case 'column':         value = node.style.paddingTop;    break;\n      case 'column-reverse': value = node.style.paddingBottom; break;\n    }\n\n    if (value != null && value >= 0) {\n      return value;\n    }\n\n    if (node.style.padding !== undefined && node.style.padding >= 0) {\n      return node.style.padding;\n    }\n\n    return 0;\n  }\n\n  function getTrailingPadding(node, axis) {\n    if (node.style.paddingEnd !== undefined && node.style.paddingEnd >= 0\n        && isRowDirection(axis)) {\n      return node.style.paddingEnd;\n    }\n\n    var value = null;\n    switch (axis) {\n      case 'row':            value = node.style.paddingRight;  break;\n      case 'row-reverse':    value = node.style.paddingLeft;   break;\n      case 'column':         value = node.style.paddingBottom; break;\n      case 'column-reverse': value = node.style.paddingTop;    break;\n    }\n\n    if (value != null && value >= 0) {\n      return value;\n    }\n\n    if (node.style.padding !== undefined && node.style.padding >= 0) {\n      return node.style.padding;\n    }\n\n    return 0;\n  }\n\n  function getLeadingBorder(node, axis) {\n    if (node.style.borderStartWidth !== undefined && node.style.borderStartWidth >= 0\n        && isRowDirection(axis)) {\n      return node.style.borderStartWidth;\n    }\n\n    var value = null;\n    switch (axis) {\n      case 'row':            value = node.style.borderLeftWidth;   break;\n      case 'row-reverse':    value = node.style.borderRightWidth;  break;\n      case 'column':         value = node.style.borderTopWidth;    break;\n      case 'column-reverse': value = node.style.borderBottomWidth; break;\n    }\n\n    if (value != null && value >= 0) {\n      return value;\n    }\n\n    if (node.style.borderWidth !== undefined && node.style.borderWidth >= 0) {\n      return node.style.borderWidth;\n    }\n\n    return 0;\n  }\n\n  function getTrailingBorder(node, axis) {\n    if (node.style.borderEndWidth !== undefined && node.style.borderEndWidth >= 0\n        && isRowDirection(axis)) {\n      return node.style.borderEndWidth;\n    }\n\n    var value = null;\n    switch (axis) {\n      case 'row':            value = node.style.borderRightWidth;  break;\n      case 'row-reverse':    value = node.style.borderLeftWidth;   break;\n      case 'column':         value = node.style.borderBottomWidth; break;\n      case 'column-reverse': value = node.style.borderTopWidth;    break;\n    }\n\n    if (value != null && value >= 0) {\n      return value;\n    }\n\n    if (node.style.borderWidth !== undefined && node.style.borderWidth >= 0) {\n      return node.style.borderWidth;\n    }\n\n    return 0;\n  }\n\n  function getLeadingPaddingAndBorder(node, axis) {\n    return getLeadingPadding(node, axis) + getLeadingBorder(node, axis);\n  }\n\n  function getTrailingPaddingAndBorder(node, axis) {\n    return getTrailingPadding(node, axis) + getTrailingBorder(node, axis);\n  }\n\n  function getMarginAxis(node, axis) {\n    return getLeadingMargin(node, axis) + getTrailingMargin(node, axis);\n  }\n\n  function getPaddingAndBorderAxis(node, axis) {\n    return getLeadingPaddingAndBorder(node, axis) +\n        getTrailingPaddingAndBorder(node, axis);\n  }\n\n  function getJustifyContent(node) {\n    if (node.style.justifyContent) {\n      return node.style.justifyContent;\n    }\n    return 'flex-start';\n  }\n\n  function getAlignContent(node) {\n    if (node.style.alignContent) {\n      return node.style.alignContent;\n    }\n    return 'flex-start';\n  }\n\n  function getAlignItem(node, child) {\n    if (child.style.alignSelf) {\n      return child.style.alignSelf;\n    }\n    if (node.style.alignItems) {\n      return node.style.alignItems;\n    }\n    return 'stretch';\n  }\n\n  function resolveAxis(axis, direction) {\n    if (direction === CSS_DIRECTION_RTL) {\n      if (axis === CSS_FLEX_DIRECTION_ROW) {\n        return CSS_FLEX_DIRECTION_ROW_REVERSE;\n      } else if (axis === CSS_FLEX_DIRECTION_ROW_REVERSE) {\n        return CSS_FLEX_DIRECTION_ROW;\n      }\n    }\n\n    return axis;\n  }\n\n  function resolveDirection(node, parentDirection) {\n    var direction;\n    if (node.style.direction) {\n      direction = node.style.direction;\n    } else {\n      direction = CSS_DIRECTION_INHERIT;\n    }\n\n    if (direction === CSS_DIRECTION_INHERIT) {\n      direction = (parentDirection === undefined ? CSS_DIRECTION_LTR : parentDirection);\n    }\n\n    return direction;\n  }\n\n  function getFlexDirection(node) {\n    if (node.style.flexDirection) {\n      return node.style.flexDirection;\n    }\n    return CSS_FLEX_DIRECTION_COLUMN;\n  }\n\n  function getCrossFlexDirection(flexDirection, direction) {\n    if (isColumnDirection(flexDirection)) {\n      return resolveAxis(CSS_FLEX_DIRECTION_ROW, direction);\n    } else {\n      return CSS_FLEX_DIRECTION_COLUMN;\n    }\n  }\n\n  function getPositionType(node) {\n    if (node.style.position) {\n      return node.style.position;\n    }\n    return CSS_POSITION_RELATIVE;\n  }\n\n  function getOverflow(node) {\n    if (node.style.overflow) {\n      return node.style.overflow;\n    }\n    return CSS_OVERFLOW_VISIBLE;\n  }\n\n  function isFlex(node) {\n    return (\n      getPositionType(node) === CSS_POSITION_RELATIVE &&\n      node.style.flex !== undefined && node.style.flex !== 0\n    );\n  }\n\n  function isFlexWrap(node) {\n    return node.style.flexWrap === 'wrap';\n  }\n\n  function getDimWithMargin(node, axis) {\n    return node.layout[measuredDim[axis]] + getMarginAxis(node, axis);\n  }\n\n  function isStyleDimDefined(node, axis) {\n    return node.style[dim[axis]] !== undefined && node.style[dim[axis]] >= 0;\n  }\n\n  function isLayoutDimDefined(node, axis) {\n    return node.layout[measuredDim[axis]] !== undefined && node.layout[measuredDim[axis]] >= 0;\n  }\n\n  function isLeadingPosDefined(node, axis) {\n    return (isRowDirection(axis) && !isUndefined(node.style[CSS_START]))\n     || !isUndefined(node.style[leading[axis]]);\n  }\n\n  function isTrailingPosDefined(node, axis) {\n    return (isRowDirection(axis) && !isUndefined(node.style[CSS_END]))\n     || !isUndefined(node.style[trailing[axis]]);\n  }\n\n  function isMeasureDefined(node) {\n    return node.style.measure !== undefined;\n  }\n\n  function getLeadingPosition(node, axis) {\n    if (!isUndefined(node.style[CSS_START]) && isRowDirection(axis)) {\n      return node.style[CSS_START];\n    }\n    if (!isUndefined(node.style[leading[axis]])) {\n      return node.style[leading[axis]];\n    }\n    return 0;\n  }\n\n  function getTrailingPosition(node, axis) {\n    if (!isUndefined(node.style[CSS_END])  && isRowDirection(axis)) {\n      return node.style[CSS_END];\n    }\n    if (!isUndefined(node.style[trailing[axis]])) {\n      return node.style[trailing[axis]];\n    }\n    return 0;\n  }\n\n  function boundAxisWithinMinAndMax(node, axis, value) {\n    var min = {\n      'row': node.style.minWidth,\n      'row-reverse': node.style.minWidth,\n      'column': node.style.minHeight,\n      'column-reverse': node.style.minHeight\n    }[axis];\n\n    var max = {\n      'row': node.style.maxWidth,\n      'row-reverse': node.style.maxWidth,\n      'column': node.style.maxHeight,\n      'column-reverse': node.style.maxHeight\n    }[axis];\n\n    var boundValue = value;\n    if (max !== undefined && max >= 0 && boundValue > max) {\n      boundValue = max;\n    }\n    if (min !== undefined && min >= 0 && boundValue < min) {\n      boundValue = min;\n    }\n    return boundValue;\n  }\n\n  function fminf(a, b) {\n    if (a < b) {\n      return a;\n    }\n    return b;\n  }\n\n  function fmaxf(a, b) {\n    if (a > b) {\n      return a;\n    }\n    return b;\n  }\n\n  // Like boundAxisWithinMinAndMax but also ensures that the value doesn't go below the\n  // padding and border amount.\n  function boundAxis(node, axis, value) {\n    return fmaxf(boundAxisWithinMinAndMax(node, axis, value), getPaddingAndBorderAxis(node, axis));\n  }\n\n  function setTrailingPosition(node, child, axis) {\n    var size = child.layout[measuredDim[axis]];\n    child.layout[trailing[axis]] = node.layout[measuredDim[axis]] - size - child.layout[pos[axis]];\n  }\n\n  // If both left and right are defined, then use left. Otherwise return\n  // +left or -right depending on which is defined.\n  function getRelativePosition(node, axis) {\n    if (node.style[leading[axis]] !== undefined) {\n      return getLeadingPosition(node, axis);\n    }\n    return -getTrailingPosition(node, axis);\n  }\n\n  function setPosition(node, direction) {\n    var mainAxis = resolveAxis(getFlexDirection(node), direction);\n    var crossAxis = getCrossFlexDirection(mainAxis, direction);\n\n    node.layout[leading[mainAxis]] = getLeadingMargin(node, mainAxis) +\n      getRelativePosition(node, mainAxis);\n    node.layout[trailing[mainAxis]] = getTrailingMargin(node, mainAxis) +\n      getRelativePosition(node, mainAxis);\n    node.layout[leading[crossAxis]] = getLeadingMargin(node, crossAxis) +\n      getRelativePosition(node, crossAxis);\n    node.layout[trailing[crossAxis]] = getTrailingMargin(node, crossAxis) +\n      getRelativePosition(node, crossAxis);\n  }\n\n  function assert(condition, message) {\n    if (!condition) {\n      throw new Error(message);\n    }\n  }\n\n  //\n  // This is the main routine that implements a subset of the flexbox layout algorithm\n  // described in the W3C CSS documentation: https://www.w3.org/TR/css3-flexbox/.\n  //\n  // Limitations of this algorithm, compared to the full standard:\n  //  * Display property is always assumed to be 'flex' except for Text nodes, which\n  //    are assumed to be 'inline-flex'.\n  //  * The 'zIndex' property (or any form of z ordering) is not supported. Nodes are\n  //    stacked in document order.\n  //  * The 'order' property is not supported. The order of flex items is always defined\n  //    by document order.\n  //  * The 'visibility' property is always assumed to be 'visible'. Values of 'collapse'\n  //    and 'hidden' are not supported.\n  //  * The 'wrap' property supports only 'nowrap' (which is the default) or 'wrap'. The\n  //    rarely-used 'wrap-reverse' is not supported.\n  //  * Rather than allowing arbitrary combinations of flexGrow, flexShrink and\n  //    flexBasis, this algorithm supports only the three most common combinations:\n  //      flex: 0 is equiavlent to flex: 0 0 auto\n  //      flex: n (where n is a positive value) is equivalent to flex: n 1 auto\n  //          If POSITIVE_FLEX_IS_AUTO is 0, then it is equivalent to flex: n 0 0\n  //          This is faster because the content doesn't need to be measured, but it's\n  //          less flexible because the basis is always 0 and can't be overriden with\n  //          the width/height attributes.\n  //      flex: -1 (or any negative value) is equivalent to flex: 0 1 auto\n  //  * Margins cannot be specified as 'auto'. They must be specified in terms of pixel\n  //    values, and the default value is 0.\n  //  * The 'baseline' value is not supported for alignItems and alignSelf properties.\n  //  * Values of width, maxWidth, minWidth, height, maxHeight and minHeight must be\n  //    specified as pixel values, not as percentages.\n  //  * There is no support for calculation of dimensions based on intrinsic aspect ratios\n  //     (e.g. images).\n  //  * There is no support for forced breaks.\n  //  * It does not support vertical inline directions (top-to-bottom or bottom-to-top text).\n  //\n  // Deviations from standard:\n  //  * Section 4.5 of the spec indicates that all flex items have a default minimum\n  //    main size. For text blocks, for example, this is the width of the widest word.\n  //    Calculating the minimum width is expensive, so we forego it and assume a default\n  //    minimum main size of 0.\n  //  * Min/Max sizes in the main axis are not honored when resolving flexible lengths.\n  //  * The spec indicates that the default value for 'flexDirection' is 'row', but\n  //    the algorithm below assumes a default of 'column'.\n  //\n  // Input parameters:\n  //    - node: current node to be sized and layed out\n  //    - availableWidth & availableHeight: available size to be used for sizing the node\n  //      or CSS_UNDEFINED if the size is not available; interpretation depends on layout\n  //      flags\n  //    - parentDirection: the inline (text) direction within the parent (left-to-right or\n  //      right-to-left)\n  //    - widthMeasureMode: indicates the sizing rules for the width (see below for explanation)\n  //    - heightMeasureMode: indicates the sizing rules for the height (see below for explanation)\n  //    - performLayout: specifies whether the caller is interested in just the dimensions\n  //      of the node or it requires the entire node and its subtree to be layed out\n  //      (with final positions)\n  //\n  // Details:\n  //    This routine is called recursively to lay out subtrees of flexbox elements. It uses the\n  //    information in node.style, which is treated as a read-only input. It is responsible for\n  //    setting the layout.direction and layout.measured_dimensions fields for the input node as well\n  //    as the layout.position and layout.line_index fields for its child nodes. The\n  //    layout.measured_dimensions field includes any border or padding for the node but does\n  //    not include margins.\n  //\n  //    The spec describes four different layout modes: \"fill available\", \"max content\", \"min content\",\n  //    and \"fit content\". Of these, we don't use \"min content\" because we don't support default\n  //    minimum main sizes (see above for details). Each of our measure modes maps to a layout mode\n  //    from the spec (https://www.w3.org/TR/css3-sizing/#terms):\n  //      - CSS_MEASURE_MODE_UNDEFINED: max content\n  //      - CSS_MEASURE_MODE_EXACTLY: fill available\n  //      - CSS_MEASURE_MODE_AT_MOST: fit content\n  //\n  //    When calling layoutNodeImpl and layoutNodeInternal, if the caller passes an available size of\n  //    undefined then it must also pass a measure mode of CSS_MEASURE_MODE_UNDEFINED in that dimension.\n  //\n  function layoutNodeImpl(node, availableWidth, availableHeight, /*css_direction_t*/parentDirection, widthMeasureMode, heightMeasureMode, performLayout) {\n    assert(isUndefined(availableWidth) ? widthMeasureMode === CSS_MEASURE_MODE_UNDEFINED : true, 'availableWidth is indefinite so widthMeasureMode must be CSS_MEASURE_MODE_UNDEFINED');\n    assert(isUndefined(availableHeight) ? heightMeasureMode === CSS_MEASURE_MODE_UNDEFINED : true, 'availableHeight is indefinite so heightMeasureMode must be CSS_MEASURE_MODE_UNDEFINED');\n\n    var/*float*/ paddingAndBorderAxisRow = getPaddingAndBorderAxis(node, CSS_FLEX_DIRECTION_ROW);\n    var/*float*/ paddingAndBorderAxisColumn = getPaddingAndBorderAxis(node, CSS_FLEX_DIRECTION_COLUMN);\n    var/*float*/ marginAxisRow = getMarginAxis(node, CSS_FLEX_DIRECTION_ROW);\n    var/*float*/ marginAxisColumn = getMarginAxis(node, CSS_FLEX_DIRECTION_COLUMN);\n\n    // Set the resolved resolution in the node's layout.\n    var/*css_direction_t*/ direction = resolveDirection(node, parentDirection);\n    node.layout.direction = direction;\n\n    // For content (text) nodes, determine the dimensions based on the text contents.\n    if (isMeasureDefined(node)) {\n      var/*float*/ innerWidth = availableWidth - marginAxisRow - paddingAndBorderAxisRow;\n      var/*float*/ innerHeight = availableHeight - marginAxisColumn - paddingAndBorderAxisColumn;\n\n      if (widthMeasureMode === CSS_MEASURE_MODE_EXACTLY && heightMeasureMode === CSS_MEASURE_MODE_EXACTLY) {\n\n        // Don't bother sizing the text if both dimensions are already defined.\n        node.layout.measuredWidth = boundAxis(node, CSS_FLEX_DIRECTION_ROW, availableWidth - marginAxisRow);\n        node.layout.measuredHeight = boundAxis(node, CSS_FLEX_DIRECTION_COLUMN, availableHeight - marginAxisColumn);\n      } else if (innerWidth <= 0 || innerHeight <= 0) {\n\n        // Don't bother sizing the text if there's no horizontal or vertical space.\n        node.layout.measuredWidth = boundAxis(node, CSS_FLEX_DIRECTION_ROW, 0);\n        node.layout.measuredHeight = boundAxis(node, CSS_FLEX_DIRECTION_COLUMN, 0);\n      } else {\n\n        // Measure the text under the current constraints.\n        var/*css_dim_t*/ measureDim = node.style.measure(\n          /*(c)!node->context,*/\n          /*(java)!layoutContext.measureOutput,*/\n          innerWidth,\n          widthMeasureMode,\n          innerHeight,\n          heightMeasureMode\n        );\n\n        node.layout.measuredWidth = boundAxis(node, CSS_FLEX_DIRECTION_ROW,\n          (widthMeasureMode === CSS_MEASURE_MODE_UNDEFINED || widthMeasureMode === CSS_MEASURE_MODE_AT_MOST) ?\n            measureDim.width + paddingAndBorderAxisRow :\n            availableWidth - marginAxisRow);\n        node.layout.measuredHeight = boundAxis(node, CSS_FLEX_DIRECTION_COLUMN,\n          (heightMeasureMode === CSS_MEASURE_MODE_UNDEFINED || heightMeasureMode === CSS_MEASURE_MODE_AT_MOST) ?\n            measureDim.height + paddingAndBorderAxisColumn :\n            availableHeight - marginAxisColumn);\n      }\n\n      return;\n    }\n\n    // For nodes with no children, use the available values if they were provided, or\n    // the minimum size as indicated by the padding and border sizes.\n    var/*int*/ childCount = node.children.length;\n    if (childCount === 0) {\n      node.layout.measuredWidth = boundAxis(node, CSS_FLEX_DIRECTION_ROW,\n        (widthMeasureMode === CSS_MEASURE_MODE_UNDEFINED || widthMeasureMode === CSS_MEASURE_MODE_AT_MOST) ?\n          paddingAndBorderAxisRow :\n          availableWidth - marginAxisRow);\n      node.layout.measuredHeight = boundAxis(node, CSS_FLEX_DIRECTION_COLUMN,\n        (heightMeasureMode === CSS_MEASURE_MODE_UNDEFINED || heightMeasureMode === CSS_MEASURE_MODE_AT_MOST) ?\n          paddingAndBorderAxisColumn :\n          availableHeight - marginAxisColumn);\n      return;\n    }\n\n    // If we're not being asked to perform a full layout, we can handle a number of common\n    // cases here without incurring the cost of the remaining function.\n    if (!performLayout) {\n      // If we're being asked to size the content with an at most constraint but there is no available width,\n      // the measurement will always be zero.\n      if (widthMeasureMode === CSS_MEASURE_MODE_AT_MOST && availableWidth <= 0 &&\n          heightMeasureMode === CSS_MEASURE_MODE_AT_MOST && availableHeight <= 0) {\n        node.layout.measuredWidth = boundAxis(node, CSS_FLEX_DIRECTION_ROW, 0);\n        node.layout.measuredHeight = boundAxis(node, CSS_FLEX_DIRECTION_COLUMN, 0);\n        return;\n      }\n\n      if (widthMeasureMode === CSS_MEASURE_MODE_AT_MOST && availableWidth <= 0) {\n        node.layout.measuredWidth = boundAxis(node, CSS_FLEX_DIRECTION_ROW, 0);\n        node.layout.measuredHeight = boundAxis(node, CSS_FLEX_DIRECTION_COLUMN, isUndefined(availableHeight) ? 0 : (availableHeight - marginAxisColumn));\n        return;\n      }\n\n      if (heightMeasureMode === CSS_MEASURE_MODE_AT_MOST && availableHeight <= 0) {\n        node.layout.measuredWidth = boundAxis(node, CSS_FLEX_DIRECTION_ROW, isUndefined(availableWidth) ? 0 : (availableWidth - marginAxisRow));\n        node.layout.measuredHeight = boundAxis(node, CSS_FLEX_DIRECTION_COLUMN, 0);\n        return;\n      }\n\n      // If we're being asked to use an exact width/height, there's no need to measure the children.\n      if (widthMeasureMode === CSS_MEASURE_MODE_EXACTLY && heightMeasureMode === CSS_MEASURE_MODE_EXACTLY) {\n        node.layout.measuredWidth = boundAxis(node, CSS_FLEX_DIRECTION_ROW, availableWidth - marginAxisRow);\n        node.layout.measuredHeight = boundAxis(node, CSS_FLEX_DIRECTION_COLUMN, availableHeight - marginAxisColumn);\n        return;\n      }\n    }\n\n    // STEP 1: CALCULATE VALUES FOR REMAINDER OF ALGORITHM\n    var/*(c)!css_flex_direction_t*//*(java)!int*/ mainAxis = resolveAxis(getFlexDirection(node), direction);\n    var/*(c)!css_flex_direction_t*//*(java)!int*/ crossAxis = getCrossFlexDirection(mainAxis, direction);\n    var/*bool*/ isMainAxisRow = isRowDirection(mainAxis);\n    var/*css_justify_t*/ justifyContent = getJustifyContent(node);\n    var/*bool*/ isNodeFlexWrap = isFlexWrap(node);\n\n    var/*css_node_t**/ firstAbsoluteChild = undefined;\n    var/*css_node_t**/ currentAbsoluteChild = undefined;\n\n    var/*float*/ leadingPaddingAndBorderMain = getLeadingPaddingAndBorder(node, mainAxis);\n    var/*float*/ trailingPaddingAndBorderMain = getTrailingPaddingAndBorder(node, mainAxis);\n    var/*float*/ leadingPaddingAndBorderCross = getLeadingPaddingAndBorder(node, crossAxis);\n    var/*float*/ paddingAndBorderAxisMain = getPaddingAndBorderAxis(node, mainAxis);\n    var/*float*/ paddingAndBorderAxisCross = getPaddingAndBorderAxis(node, crossAxis);\n\n    var/*css_measure_mode_t*/ measureModeMainDim = isMainAxisRow ? widthMeasureMode : heightMeasureMode;\n    var/*css_measure_mode_t*/ measureModeCrossDim = isMainAxisRow ? heightMeasureMode : widthMeasureMode;\n\n    // STEP 2: DETERMINE AVAILABLE SIZE IN MAIN AND CROSS DIRECTIONS\n    var/*float*/ availableInnerWidth = availableWidth - marginAxisRow - paddingAndBorderAxisRow;\n    var/*float*/ availableInnerHeight = availableHeight - marginAxisColumn - paddingAndBorderAxisColumn;\n    var/*float*/ availableInnerMainDim = isMainAxisRow ? availableInnerWidth : availableInnerHeight;\n    var/*float*/ availableInnerCrossDim = isMainAxisRow ? availableInnerHeight : availableInnerWidth;\n\n    // STEP 3: DETERMINE FLEX BASIS FOR EACH ITEM\n    var/*css_node_t**/ child;\n    var/*int*/ i;\n    var/*float*/ childWidth;\n    var/*float*/ childHeight;\n    var/*css_measure_mode_t*/ childWidthMeasureMode;\n    var/*css_measure_mode_t*/ childHeightMeasureMode;\n    for (i = 0; i < childCount; i++) {\n      child = node.children[i];\n\n      if (performLayout) {\n        // Set the initial position (relative to the parent).\n        var/*css_direction_t*/ childDirection = resolveDirection(child, direction);\n        setPosition(child, childDirection);\n      }\n\n      // Absolute-positioned children don't participate in flex layout. Add them\n      // to a list that we can process later.\n      if (getPositionType(child) === CSS_POSITION_ABSOLUTE) {\n\n        // Store a private linked list of absolutely positioned children\n        // so that we can efficiently traverse them later.\n        if (firstAbsoluteChild === undefined) {\n          firstAbsoluteChild = child;\n        }\n        if (currentAbsoluteChild !== undefined) {\n          currentAbsoluteChild.nextChild = child;\n        }\n        currentAbsoluteChild = child;\n        child.nextChild = undefined;\n      } else {\n\n        if (isMainAxisRow && isStyleDimDefined(child, CSS_FLEX_DIRECTION_ROW)) {\n\n          // The width is definite, so use that as the flex basis.\n          child.layout.flexBasis = fmaxf(child.style.width, getPaddingAndBorderAxis(child, CSS_FLEX_DIRECTION_ROW));\n        } else if (!isMainAxisRow && isStyleDimDefined(child, CSS_FLEX_DIRECTION_COLUMN)) {\n\n          // The height is definite, so use that as the flex basis.\n          child.layout.flexBasis = fmaxf(child.style.height, getPaddingAndBorderAxis(child, CSS_FLEX_DIRECTION_COLUMN));\n        } else if (!isFlexBasisAuto(child) && !isUndefined(availableInnerMainDim)) {\n\n          // If the basis isn't 'auto', it is assumed to be zero.\n          child.layout.flexBasis = fmaxf(0, getPaddingAndBorderAxis(child, mainAxis));\n        } else {\n\n          childWidth = CSS_UNDEFINED;\n          childHeight = CSS_UNDEFINED;\n          childWidthMeasureMode = CSS_MEASURE_MODE_UNDEFINED;\n          childHeightMeasureMode = CSS_MEASURE_MODE_UNDEFINED;\n\n          // Main axis\n          if (isMainAxisRow) {\n            if (widthMeasureMode == CSS_MEASURE_MODE_UNDEFINED || isUndefined(availableInnerMainDim)) {\n              childWidth = CSS_UNDEFINED;\n              childWidthMeasureMode = CSS_MEASURE_MODE_UNDEFINED;\n            } else {\n              childWidth = availableInnerMainDim;\n              childWidthMeasureMode = CSS_MEASURE_MODE_AT_MOST;\n            }\n          } else if (getOverflow(node) === CSS_OVERFLOW_HIDDEN) {\n            if (heightMeasureMode == CSS_MEASURE_MODE_UNDEFINED || isUndefined(availableInnerMainDim)) {\n              childHeight = CSS_UNDEFINED;\n              childHeightMeasureMode = CSS_MEASURE_MODE_UNDEFINED;\n            } else {\n              childHeight = availableInnerMainDim;\n              childHeightMeasureMode = CSS_MEASURE_MODE_AT_MOST;\n            }\n          }\n\n          // Cross axis\n          if (isMainAxisRow) {\n            if (getOverflow(node) === CSS_OVERFLOW_HIDDEN) {\n              if (!isUndefined(availableInnerCrossDim) &&\n                  !isStyleDimDefined(child, CSS_FLEX_DIRECTION_COLUMN) &&\n                  heightMeasureMode == CSS_MEASURE_MODE_EXACTLY &&\n                  getAlignItem(node, child) == CSS_ALIGN_STRETCH) {\n                childHeight = availableInnerCrossDim;\n                childHeightMeasureMode = CSS_MEASURE_MODE_EXACTLY;\n              } else if (!isStyleDimDefined(child, CSS_FLEX_DIRECTION_COLUMN)) {\n                childHeight = availableInnerCrossDim;\n                childHeightMeasureMode = isUndefined(childHeight) ? CSS_MEASURE_MODE_UNDEFINED : CSS_MEASURE_MODE_AT_MOST;\n              } else {\n                childHeight = child.style.height + getMarginAxis(child, CSS_FLEX_DIRECTION_COLUMN);\n                childHeightMeasureMode = CSS_MEASURE_MODE_EXACTLY;\n              }\n            }\n          } else {\n            if (!isUndefined(availableInnerCrossDim) &&\n                !isStyleDimDefined(child, CSS_FLEX_DIRECTION_ROW) &&\n                widthMeasureMode == CSS_MEASURE_MODE_EXACTLY &&\n                getAlignItem(node, child) == CSS_ALIGN_STRETCH) {\n              childWidth = availableInnerCrossDim;\n              childWidthMeasureMode = CSS_MEASURE_MODE_EXACTLY;\n            } else if (!isStyleDimDefined(child, CSS_FLEX_DIRECTION_ROW)) {\n              childWidth = availableInnerCrossDim;\n              childWidthMeasureMode = isUndefined(childWidth) ? CSS_MEASURE_MODE_UNDEFINED : CSS_MEASURE_MODE_AT_MOST;\n            } else {\n              childWidth = child.style.width + getMarginAxis(child, CSS_FLEX_DIRECTION_ROW);\n              childWidthMeasureMode = CSS_MEASURE_MODE_EXACTLY;\n            }\n          }\n\n          // Measure the child\n          layoutNodeInternal(child, childWidth, childHeight, direction, childWidthMeasureMode, childHeightMeasureMode, false, 'measure');\n\n          child.layout.flexBasis = fmaxf(isMainAxisRow ? child.layout.measuredWidth : child.layout.measuredHeight, getPaddingAndBorderAxis(child, mainAxis));\n        }\n      }\n    }\n\n    // STEP 4: COLLECT FLEX ITEMS INTO FLEX LINES\n\n    // Indexes of children that represent the first and last items in the line.\n    var/*int*/ startOfLineIndex = 0;\n    var/*int*/ endOfLineIndex = 0;\n\n    // Number of lines.\n    var/*int*/ lineCount = 0;\n\n    // Accumulated cross dimensions of all lines so far.\n    var/*float*/ totalLineCrossDim = 0;\n\n    // Max main dimension of all the lines.\n    var/*float*/ maxLineMainDim = 0;\n\n    while (endOfLineIndex < childCount) {\n\n      // Number of items on the currently line. May be different than the difference\n      // between start and end indicates because we skip over absolute-positioned items.\n      var/*int*/ itemsOnLine = 0;\n\n      // sizeConsumedOnCurrentLine is accumulation of the dimensions and margin\n      // of all the children on the current line. This will be used in order to\n      // either set the dimensions of the node if none already exist or to compute\n      // the remaining space left for the flexible children.\n      var/*float*/ sizeConsumedOnCurrentLine = 0;\n\n      var/*float*/ totalFlexGrowFactors = 0;\n      var/*float*/ totalFlexShrinkScaledFactors = 0;\n\n      i = startOfLineIndex;\n\n      // Maintain a linked list of the child nodes that can shrink and/or grow.\n      var/*css_node_t**/ firstRelativeChild = undefined;\n      var/*css_node_t**/ currentRelativeChild = undefined;\n\n      // Add items to the current line until it's full or we run out of items.\n      while (i < childCount) {\n        child = node.children[i];\n        child.lineIndex = lineCount;\n\n        if (getPositionType(child) !== CSS_POSITION_ABSOLUTE) {\n          var/*float*/ outerFlexBasis = child.layout.flexBasis + getMarginAxis(child, mainAxis);\n\n          // If this is a multi-line flow and this item pushes us over the available size, we've\n          // hit the end of the current line. Break out of the loop and lay out the current line.\n          if (sizeConsumedOnCurrentLine + outerFlexBasis > availableInnerMainDim && isNodeFlexWrap && itemsOnLine > 0) {\n            break;\n          }\n\n          sizeConsumedOnCurrentLine += outerFlexBasis;\n          itemsOnLine++;\n\n          if (isFlex(child)) {\n            totalFlexGrowFactors += getFlexGrowFactor(child);\n\n            // Unlike the grow factor, the shrink factor is scaled relative to the child\n            // dimension.\n            totalFlexShrinkScaledFactors += getFlexShrinkFactor(child) * child.layout.flexBasis;\n          }\n\n          // Store a private linked list of children that need to be layed out.\n          if (firstRelativeChild === undefined) {\n            firstRelativeChild = child;\n          }\n          if (currentRelativeChild !== undefined) {\n            currentRelativeChild.nextChild = child;\n          }\n          currentRelativeChild = child;\n          child.nextChild = undefined;\n        }\n\n        i++;\n        endOfLineIndex++;\n      }\n\n      // If we don't need to measure the cross axis, we can skip the entire flex step.\n      var/*bool*/ canSkipFlex = !performLayout && measureModeCrossDim === CSS_MEASURE_MODE_EXACTLY;\n\n      // In order to position the elements in the main axis, we have two\n      // controls. The space between the beginning and the first element\n      // and the space between each two elements.\n      var/*float*/ leadingMainDim = 0;\n      var/*float*/ betweenMainDim = 0;\n\n      // STEP 5: RESOLVING FLEXIBLE LENGTHS ON MAIN AXIS\n      // Calculate the remaining available space that needs to be allocated.\n      // If the main dimension size isn't known, it is computed based on\n      // the line length, so there's no more space left to distribute.\n      var/*float*/ remainingFreeSpace = 0;\n      if (!isUndefined(availableInnerMainDim)) {\n        remainingFreeSpace = availableInnerMainDim - sizeConsumedOnCurrentLine;\n      } else if (sizeConsumedOnCurrentLine < 0) {\n        // availableInnerMainDim is indefinite which means the node is being sized based on its content.\n        // sizeConsumedOnCurrentLine is negative which means the node will allocate 0 pixels for\n        // its content. Consequently, remainingFreeSpace is 0 - sizeConsumedOnCurrentLine.\n        remainingFreeSpace = -sizeConsumedOnCurrentLine;\n      }\n\n      var/*float*/ originalRemainingFreeSpace = remainingFreeSpace;\n      var/*float*/ deltaFreeSpace = 0;\n\n      if (!canSkipFlex) {\n        var/*float*/ childFlexBasis;\n        var/*float*/ flexShrinkScaledFactor;\n        var/*float*/ flexGrowFactor;\n        var/*float*/ baseMainSize;\n        var/*float*/ boundMainSize;\n\n        // Do two passes over the flex items to figure out how to distribute the remaining space.\n        // The first pass finds the items whose min/max constraints trigger, freezes them at those\n        // sizes, and excludes those sizes from the remaining space. The second pass sets the size\n        // of each flexible item. It distributes the remaining space amongst the items whose min/max\n        // constraints didn't trigger in pass 1. For the other items, it sets their sizes by forcing\n        // their min/max constraints to trigger again.\n        //\n        // This two pass approach for resolving min/max constraints deviates from the spec. The\n        // spec (https://www.w3.org/TR/css-flexbox-1/#resolve-flexible-lengths) describes a process\n        // that needs to be repeated a variable number of times. The algorithm implemented here\n        // won't handle all cases but it was simpler to implement and it mitigates performance\n        // concerns because we know exactly how many passes it'll do.\n\n        // First pass: detect the flex items whose min/max constraints trigger\n        var/*float*/ deltaFlexShrinkScaledFactors = 0;\n        var/*float*/ deltaFlexGrowFactors = 0;\n        currentRelativeChild = firstRelativeChild;\n        while (currentRelativeChild !== undefined) {\n          childFlexBasis = currentRelativeChild.layout.flexBasis;\n\n          if (remainingFreeSpace < 0) {\n            flexShrinkScaledFactor = getFlexShrinkFactor(currentRelativeChild) * childFlexBasis;\n\n            // Is this child able to shrink?\n            if (flexShrinkScaledFactor !== 0) {\n              baseMainSize = childFlexBasis +\n                remainingFreeSpace / totalFlexShrinkScaledFactors * flexShrinkScaledFactor;\n              boundMainSize = boundAxis(currentRelativeChild, mainAxis, baseMainSize);\n              if (baseMainSize !== boundMainSize) {\n                // By excluding this item's size and flex factor from remaining, this item's\n                // min/max constraints should also trigger in the second pass resulting in the\n                // item's size calculation being identical in the first and second passes.\n                deltaFreeSpace -= boundMainSize - childFlexBasis;\n                deltaFlexShrinkScaledFactors -= flexShrinkScaledFactor;\n              }\n            }\n          } else if (remainingFreeSpace > 0) {\n            flexGrowFactor = getFlexGrowFactor(currentRelativeChild);\n\n            // Is this child able to grow?\n            if (flexGrowFactor !== 0) {\n              baseMainSize = childFlexBasis +\n                remainingFreeSpace / totalFlexGrowFactors * flexGrowFactor;\n              boundMainSize = boundAxis(currentRelativeChild, mainAxis, baseMainSize);\n              if (baseMainSize !== boundMainSize) {\n                // By excluding this item's size and flex factor from remaining, this item's\n                // min/max constraints should also trigger in the second pass resulting in the\n                // item's size calculation being identical in the first and second passes.\n                deltaFreeSpace -= boundMainSize - childFlexBasis;\n                deltaFlexGrowFactors -= flexGrowFactor;\n              }\n            }\n          }\n\n          currentRelativeChild = currentRelativeChild.nextChild;\n        }\n\n        totalFlexShrinkScaledFactors += deltaFlexShrinkScaledFactors;\n        totalFlexGrowFactors += deltaFlexGrowFactors;\n        remainingFreeSpace += deltaFreeSpace;\n\n        // Second pass: resolve the sizes of the flexible items\n        deltaFreeSpace = 0;\n        currentRelativeChild = firstRelativeChild;\n        while (currentRelativeChild !== undefined) {\n          childFlexBasis = currentRelativeChild.layout.flexBasis;\n          var/*float*/ updatedMainSize = childFlexBasis;\n\n          if (remainingFreeSpace < 0) {\n            flexShrinkScaledFactor = getFlexShrinkFactor(currentRelativeChild) * childFlexBasis;\n\n            // Is this child able to shrink?\n            if (flexShrinkScaledFactor !== 0) {\n              updatedMainSize = boundAxis(currentRelativeChild, mainAxis, childFlexBasis +\n                remainingFreeSpace / totalFlexShrinkScaledFactors * flexShrinkScaledFactor);\n            }\n          } else if (remainingFreeSpace > 0) {\n            flexGrowFactor = getFlexGrowFactor(currentRelativeChild);\n\n            // Is this child able to grow?\n            if (flexGrowFactor !== 0) {\n              updatedMainSize = boundAxis(currentRelativeChild, mainAxis, childFlexBasis +\n                remainingFreeSpace / totalFlexGrowFactors * flexGrowFactor);\n            }\n          }\n\n          deltaFreeSpace -= updatedMainSize - childFlexBasis;\n\n          if (isMainAxisRow) {\n            childWidth = updatedMainSize + getMarginAxis(currentRelativeChild, CSS_FLEX_DIRECTION_ROW);\n            childWidthMeasureMode = CSS_MEASURE_MODE_EXACTLY;\n\n            if (!isUndefined(availableInnerCrossDim) &&\n                !isStyleDimDefined(currentRelativeChild, CSS_FLEX_DIRECTION_COLUMN) &&\n                heightMeasureMode == CSS_MEASURE_MODE_EXACTLY &&\n                getAlignItem(node, currentRelativeChild) == CSS_ALIGN_STRETCH) {\n              childHeight = availableInnerCrossDim;\n              childHeightMeasureMode = CSS_MEASURE_MODE_EXACTLY;\n            } else if (!isStyleDimDefined(currentRelativeChild, CSS_FLEX_DIRECTION_COLUMN)) {\n              childHeight = availableInnerCrossDim;\n              childHeightMeasureMode = isUndefined(childHeight) ? CSS_MEASURE_MODE_UNDEFINED : CSS_MEASURE_MODE_AT_MOST;\n            } else {\n              childHeight = currentRelativeChild.style.height + getMarginAxis(currentRelativeChild, CSS_FLEX_DIRECTION_COLUMN);\n              childHeightMeasureMode = CSS_MEASURE_MODE_EXACTLY;\n            }\n          } else {\n            childHeight = updatedMainSize + getMarginAxis(currentRelativeChild, CSS_FLEX_DIRECTION_COLUMN);\n            childHeightMeasureMode = CSS_MEASURE_MODE_EXACTLY;\n\n            if (!isUndefined(availableInnerCrossDim) &&\n                !isStyleDimDefined(currentRelativeChild, CSS_FLEX_DIRECTION_ROW) &&\n                widthMeasureMode == CSS_MEASURE_MODE_EXACTLY &&\n                getAlignItem(node, currentRelativeChild) == CSS_ALIGN_STRETCH) {\n              childWidth = availableInnerCrossDim;\n              childWidthMeasureMode = CSS_MEASURE_MODE_EXACTLY;\n            } else if (!isStyleDimDefined(currentRelativeChild, CSS_FLEX_DIRECTION_ROW)) {\n              childWidth = availableInnerCrossDim;\n              childWidthMeasureMode = isUndefined(childWidth) ? CSS_MEASURE_MODE_UNDEFINED : CSS_MEASURE_MODE_AT_MOST;\n            } else {\n              childWidth = currentRelativeChild.style.width + getMarginAxis(currentRelativeChild, CSS_FLEX_DIRECTION_ROW);\n              childWidthMeasureMode = CSS_MEASURE_MODE_EXACTLY;\n            }\n          }\n\n          var/*bool*/ requiresStretchLayout = !isStyleDimDefined(currentRelativeChild, crossAxis) &&\n            getAlignItem(node, currentRelativeChild) === CSS_ALIGN_STRETCH;\n\n          // Recursively call the layout algorithm for this child with the updated main size.\n          layoutNodeInternal(currentRelativeChild, childWidth, childHeight, direction, childWidthMeasureMode, childHeightMeasureMode, performLayout && !requiresStretchLayout, 'flex');\n\n          currentRelativeChild = currentRelativeChild.nextChild;\n        }\n      }\n\n      remainingFreeSpace = originalRemainingFreeSpace + deltaFreeSpace;\n\n      // STEP 6: MAIN-AXIS JUSTIFICATION & CROSS-AXIS SIZE DETERMINATION\n\n      // At this point, all the children have their dimensions set in the main axis.\n      // Their dimensions are also set in the cross axis with the exception of items\n      // that are aligned 'stretch'. We need to compute these stretch values and\n      // set the final positions.\n\n      // If we are using \"at most\" rules in the main axis, we won't distribute\n      // any remaining space at this point.\n      if (measureModeMainDim === CSS_MEASURE_MODE_AT_MOST) {\n        remainingFreeSpace = 0;\n      }\n\n      // Use justifyContent to figure out how to allocate the remaining space\n      // available in the main axis.\n      if (justifyContent !== CSS_JUSTIFY_FLEX_START) {\n        if (justifyContent === CSS_JUSTIFY_CENTER) {\n          leadingMainDim = remainingFreeSpace / 2;\n        } else if (justifyContent === CSS_JUSTIFY_FLEX_END) {\n          leadingMainDim = remainingFreeSpace;\n        } else if (justifyContent === CSS_JUSTIFY_SPACE_BETWEEN) {\n          remainingFreeSpace = fmaxf(remainingFreeSpace, 0);\n          if (itemsOnLine > 1) {\n            betweenMainDim = remainingFreeSpace / (itemsOnLine - 1);\n          } else {\n            betweenMainDim = 0;\n          }\n        } else if (justifyContent === CSS_JUSTIFY_SPACE_AROUND) {\n          // Space on the edges is half of the space between elements\n          betweenMainDim = remainingFreeSpace / itemsOnLine;\n          leadingMainDim = betweenMainDim / 2;\n        }\n      }\n\n      var/*float*/ mainDim = leadingPaddingAndBorderMain + leadingMainDim;\n      var/*float*/ crossDim = 0;\n\n      for (i = startOfLineIndex; i < endOfLineIndex; ++i) {\n        child = node.children[i];\n\n        if (getPositionType(child) === CSS_POSITION_ABSOLUTE &&\n            isLeadingPosDefined(child, mainAxis)) {\n          if (performLayout) {\n            // In case the child is position absolute and has left/top being\n            // defined, we override the position to whatever the user said\n            // (and margin/border).\n            child.layout[pos[mainAxis]] = getLeadingPosition(child, mainAxis) +\n              getLeadingBorder(node, mainAxis) +\n              getLeadingMargin(child, mainAxis);\n          }\n        } else {\n          if (performLayout) {\n            // If the child is position absolute (without top/left) or relative,\n            // we put it at the current accumulated offset.\n            child.layout[pos[mainAxis]] += mainDim;\n          }\n\n          // Now that we placed the element, we need to update the variables.\n          // We need to do that only for relative elements. Absolute elements\n          // do not take part in that phase.\n          if (getPositionType(child) === CSS_POSITION_RELATIVE) {\n            if (canSkipFlex) {\n              // If we skipped the flex step, then we can't rely on the measuredDims because\n              // they weren't computed. This means we can't call getDimWithMargin.\n              mainDim += betweenMainDim + getMarginAxis(child, mainAxis) + child.layout.flexBasis;\n              crossDim = availableInnerCrossDim;\n            } else {\n              // The main dimension is the sum of all the elements dimension plus\n              // the spacing.\n              mainDim += betweenMainDim + getDimWithMargin(child, mainAxis);\n\n              // The cross dimension is the max of the elements dimension since there\n              // can only be one element in that cross dimension.\n              crossDim = fmaxf(crossDim, getDimWithMargin(child, crossAxis));\n            }\n          }\n        }\n      }\n\n      mainDim += trailingPaddingAndBorderMain;\n\n      var/*float*/ containerCrossAxis = availableInnerCrossDim;\n      if (measureModeCrossDim === CSS_MEASURE_MODE_UNDEFINED || measureModeCrossDim === CSS_MEASURE_MODE_AT_MOST) {\n        // Compute the cross axis from the max cross dimension of the children.\n        containerCrossAxis = boundAxis(node, crossAxis, crossDim + paddingAndBorderAxisCross) - paddingAndBorderAxisCross;\n\n        if (measureModeCrossDim === CSS_MEASURE_MODE_AT_MOST) {\n          containerCrossAxis = fminf(containerCrossAxis, availableInnerCrossDim);\n        }\n      }\n\n      // If there's no flex wrap, the cross dimension is defined by the container.\n      if (!isNodeFlexWrap && measureModeCrossDim === CSS_MEASURE_MODE_EXACTLY) {\n        crossDim = availableInnerCrossDim;\n      }\n\n      // Clamp to the min/max size specified on the container.\n      crossDim = boundAxis(node, crossAxis, crossDim + paddingAndBorderAxisCross) - paddingAndBorderAxisCross;\n\n      // STEP 7: CROSS-AXIS ALIGNMENT\n      // We can skip child alignment if we're just measuring the container.\n      if (performLayout) {\n        for (i = startOfLineIndex; i < endOfLineIndex; ++i) {\n          child = node.children[i];\n\n          if (getPositionType(child) === CSS_POSITION_ABSOLUTE) {\n            // If the child is absolutely positioned and has a top/left/bottom/right\n            // set, override all the previously computed positions to set it correctly.\n            if (isLeadingPosDefined(child, crossAxis)) {\n              child.layout[pos[crossAxis]] = getLeadingPosition(child, crossAxis) +\n                getLeadingBorder(node, crossAxis) +\n                getLeadingMargin(child, crossAxis);\n            } else {\n              child.layout[pos[crossAxis]] = leadingPaddingAndBorderCross +\n                getLeadingMargin(child, crossAxis);\n            }\n          } else {\n            var/*float*/ leadingCrossDim = leadingPaddingAndBorderCross;\n\n            // For a relative children, we're either using alignItems (parent) or\n            // alignSelf (child) in order to determine the position in the cross axis\n            var/*css_align_t*/ alignItem = getAlignItem(node, child);\n\n            // If the child uses align stretch, we need to lay it out one more time, this time\n            // forcing the cross-axis size to be the computed cross size for the current line.\n            if (alignItem === CSS_ALIGN_STRETCH) {\n              childWidth = child.layout.measuredWidth + getMarginAxis(child, CSS_FLEX_DIRECTION_ROW);\n              childHeight = child.layout.measuredHeight + getMarginAxis(child, CSS_FLEX_DIRECTION_COLUMN);\n              var/*bool*/ isCrossSizeDefinite = false;\n\n              if (isMainAxisRow) {\n                isCrossSizeDefinite = isStyleDimDefined(child, CSS_FLEX_DIRECTION_COLUMN);\n                childHeight = crossDim;\n              } else {\n                isCrossSizeDefinite = isStyleDimDefined(child, CSS_FLEX_DIRECTION_ROW);\n                childWidth = crossDim;\n              }\n\n              // If the child defines a definite size for its cross axis, there's no need to stretch.\n              if (!isCrossSizeDefinite) {\n                childWidthMeasureMode = isUndefined(childWidth) ? CSS_MEASURE_MODE_UNDEFINED : CSS_MEASURE_MODE_EXACTLY;\n                childHeightMeasureMode = isUndefined(childHeight) ? CSS_MEASURE_MODE_UNDEFINED : CSS_MEASURE_MODE_EXACTLY;\n                layoutNodeInternal(child, childWidth, childHeight, direction, childWidthMeasureMode, childHeightMeasureMode, true, 'stretch');\n              }\n            } else if (alignItem !== CSS_ALIGN_FLEX_START) {\n              var/*float*/ remainingCrossDim = containerCrossAxis - getDimWithMargin(child, crossAxis);\n\n              if (alignItem === CSS_ALIGN_CENTER) {\n                leadingCrossDim += remainingCrossDim / 2;\n              } else { // CSS_ALIGN_FLEX_END\n                leadingCrossDim += remainingCrossDim;\n              }\n            }\n\n            // And we apply the position\n            child.layout[pos[crossAxis]] += totalLineCrossDim + leadingCrossDim;\n          }\n        }\n      }\n\n      totalLineCrossDim += crossDim;\n      maxLineMainDim = fmaxf(maxLineMainDim, mainDim);\n\n      // Reset variables for new line.\n      lineCount++;\n      startOfLineIndex = endOfLineIndex;\n      endOfLineIndex = startOfLineIndex;\n    }\n\n    // STEP 8: MULTI-LINE CONTENT ALIGNMENT\n    if (lineCount > 1 && performLayout && !isUndefined(availableInnerCrossDim)) {\n      var/*float*/ remainingAlignContentDim = availableInnerCrossDim - totalLineCrossDim;\n\n      var/*float*/ crossDimLead = 0;\n      var/*float*/ currentLead = leadingPaddingAndBorderCross;\n\n      var/*css_align_t*/ alignContent = getAlignContent(node);\n      if (alignContent === CSS_ALIGN_FLEX_END) {\n        currentLead += remainingAlignContentDim;\n      } else if (alignContent === CSS_ALIGN_CENTER) {\n        currentLead += remainingAlignContentDim / 2;\n      } else if (alignContent === CSS_ALIGN_STRETCH) {\n        if (availableInnerCrossDim > totalLineCrossDim) {\n          crossDimLead = (remainingAlignContentDim / lineCount);\n        }\n      }\n\n      var/*int*/ endIndex = 0;\n      for (i = 0; i < lineCount; ++i) {\n        var/*int*/ startIndex = endIndex;\n        var/*int*/ j;\n\n        // compute the line's height and find the endIndex\n        var/*float*/ lineHeight = 0;\n        for (j = startIndex; j < childCount; ++j) {\n          child = node.children[j];\n          if (getPositionType(child) !== CSS_POSITION_RELATIVE) {\n            continue;\n          }\n          if (child.lineIndex !== i) {\n            break;\n          }\n          if (isLayoutDimDefined(child, crossAxis)) {\n            lineHeight = fmaxf(lineHeight,\n              child.layout[measuredDim[crossAxis]] + getMarginAxis(child, crossAxis));\n          }\n        }\n        endIndex = j;\n        lineHeight += crossDimLead;\n\n        if (performLayout) {\n          for (j = startIndex; j < endIndex; ++j) {\n            child = node.children[j];\n            if (getPositionType(child) !== CSS_POSITION_RELATIVE) {\n              continue;\n            }\n\n            var/*css_align_t*/ alignContentAlignItem = getAlignItem(node, child);\n            if (alignContentAlignItem === CSS_ALIGN_FLEX_START) {\n              child.layout[pos[crossAxis]] = currentLead + getLeadingMargin(child, crossAxis);\n            } else if (alignContentAlignItem === CSS_ALIGN_FLEX_END) {\n              child.layout[pos[crossAxis]] = currentLead + lineHeight - getTrailingMargin(child, crossAxis) - child.layout[measuredDim[crossAxis]];\n            } else if (alignContentAlignItem === CSS_ALIGN_CENTER) {\n              childHeight = child.layout[measuredDim[crossAxis]];\n              child.layout[pos[crossAxis]] = currentLead + (lineHeight - childHeight) / 2;\n            } else if (alignContentAlignItem === CSS_ALIGN_STRETCH) {\n              child.layout[pos[crossAxis]] = currentLead + getLeadingMargin(child, crossAxis);\n              // TODO(prenaux): Correctly set the height of items with indefinite\n              //                (auto) crossAxis dimension.\n            }\n          }\n        }\n\n        currentLead += lineHeight;\n      }\n    }\n\n    // STEP 9: COMPUTING FINAL DIMENSIONS\n    node.layout.measuredWidth = boundAxis(node, CSS_FLEX_DIRECTION_ROW, availableWidth - marginAxisRow);\n    node.layout.measuredHeight = boundAxis(node, CSS_FLEX_DIRECTION_COLUMN, availableHeight - marginAxisColumn);\n\n    // If the user didn't specify a width or height for the node, set the\n    // dimensions based on the children.\n    if (measureModeMainDim === CSS_MEASURE_MODE_UNDEFINED) {\n      // Clamp the size to the min/max size, if specified, and make sure it\n      // doesn't go below the padding and border amount.\n      node.layout[measuredDim[mainAxis]] = boundAxis(node, mainAxis, maxLineMainDim);\n    } else if (measureModeMainDim === CSS_MEASURE_MODE_AT_MOST) {\n      node.layout[measuredDim[mainAxis]] = fmaxf(\n        fminf(availableInnerMainDim + paddingAndBorderAxisMain,\n          boundAxisWithinMinAndMax(node, mainAxis, maxLineMainDim)),\n        paddingAndBorderAxisMain);\n    }\n\n    if (measureModeCrossDim === CSS_MEASURE_MODE_UNDEFINED) {\n      // Clamp the size to the min/max size, if specified, and make sure it\n      // doesn't go below the padding and border amount.\n      node.layout[measuredDim[crossAxis]] = boundAxis(node, crossAxis, totalLineCrossDim + paddingAndBorderAxisCross);\n    } else if (measureModeCrossDim === CSS_MEASURE_MODE_AT_MOST) {\n      node.layout[measuredDim[crossAxis]] = fmaxf(\n        fminf(availableInnerCrossDim + paddingAndBorderAxisCross,\n          boundAxisWithinMinAndMax(node, crossAxis, totalLineCrossDim + paddingAndBorderAxisCross)),\n        paddingAndBorderAxisCross);\n    }\n\n    // STEP 10: SIZING AND POSITIONING ABSOLUTE CHILDREN\n    currentAbsoluteChild = firstAbsoluteChild;\n    while (currentAbsoluteChild !== undefined) {\n      // Now that we know the bounds of the container, perform layout again on the\n      // absolutely-positioned children.\n      if (performLayout) {\n\n        childWidth = CSS_UNDEFINED;\n        childHeight = CSS_UNDEFINED;\n\n        if (isStyleDimDefined(currentAbsoluteChild, CSS_FLEX_DIRECTION_ROW)) {\n          childWidth = currentAbsoluteChild.style.width + getMarginAxis(currentAbsoluteChild, CSS_FLEX_DIRECTION_ROW);\n        } else {\n          // If the child doesn't have a specified width, compute the width based on the left/right offsets if they're defined.\n          if (isLeadingPosDefined(currentAbsoluteChild, CSS_FLEX_DIRECTION_ROW) && isTrailingPosDefined(currentAbsoluteChild, CSS_FLEX_DIRECTION_ROW)) {\n            childWidth = node.layout.measuredWidth -\n              (getLeadingBorder(node, CSS_FLEX_DIRECTION_ROW) + getTrailingBorder(node, CSS_FLEX_DIRECTION_ROW)) -\n              (getLeadingPosition(currentAbsoluteChild, CSS_FLEX_DIRECTION_ROW) + getTrailingPosition(currentAbsoluteChild, CSS_FLEX_DIRECTION_ROW));\n            childWidth = boundAxis(currentAbsoluteChild, CSS_FLEX_DIRECTION_ROW, childWidth);\n          }\n        }\n\n        if (isStyleDimDefined(currentAbsoluteChild, CSS_FLEX_DIRECTION_COLUMN)) {\n          childHeight = currentAbsoluteChild.style.height + getMarginAxis(currentAbsoluteChild, CSS_FLEX_DIRECTION_COLUMN);\n        } else {\n          // If the child doesn't have a specified height, compute the height based on the top/bottom offsets if they're defined.\n          if (isLeadingPosDefined(currentAbsoluteChild, CSS_FLEX_DIRECTION_COLUMN) && isTrailingPosDefined(currentAbsoluteChild, CSS_FLEX_DIRECTION_COLUMN)) {\n            childHeight = node.layout.measuredHeight -\n              (getLeadingBorder(node, CSS_FLEX_DIRECTION_COLUMN) + getTrailingBorder(node, CSS_FLEX_DIRECTION_COLUMN)) -\n              (getLeadingPosition(currentAbsoluteChild, CSS_FLEX_DIRECTION_COLUMN) + getTrailingPosition(currentAbsoluteChild, CSS_FLEX_DIRECTION_COLUMN));\n            childHeight = boundAxis(currentAbsoluteChild, CSS_FLEX_DIRECTION_COLUMN, childHeight);\n          }\n        }\n\n        // If we're still missing one or the other dimension, measure the content.\n        if (isUndefined(childWidth) || isUndefined(childHeight)) {\n          childWidthMeasureMode = isUndefined(childWidth) ? CSS_MEASURE_MODE_UNDEFINED : CSS_MEASURE_MODE_EXACTLY;\n          childHeightMeasureMode = isUndefined(childHeight) ? CSS_MEASURE_MODE_UNDEFINED : CSS_MEASURE_MODE_EXACTLY;\n\n          // According to the spec, if the main size is not definite and the\n          // child's inline axis is parallel to the main axis (i.e. it's\n          // horizontal), the child should be sized using \"UNDEFINED\" in\n          // the main size. Otherwise use \"AT_MOST\" in the cross axis.\n          if (!isMainAxisRow && isUndefined(childWidth) && !isUndefined(availableInnerWidth)) {\n            childWidth = availableInnerWidth;\n            childWidthMeasureMode = CSS_MEASURE_MODE_AT_MOST;\n          }\n\n          // The W3C spec doesn't say anything about the 'overflow' property,\n          // but all major browsers appear to implement the following logic.\n          if (getOverflow(node) === CSS_OVERFLOW_HIDDEN) {\n            if (isMainAxisRow && isUndefined(childHeight) && !isUndefined(availableInnerHeight)) {\n              childHeight = availableInnerHeight;\n              childHeightMeasureMode = CSS_MEASURE_MODE_AT_MOST;\n            }\n          }\n\n          layoutNodeInternal(currentAbsoluteChild, childWidth, childHeight, direction, childWidthMeasureMode, childHeightMeasureMode, false, 'abs-measure');\n          childWidth = currentAbsoluteChild.layout.measuredWidth + getMarginAxis(currentAbsoluteChild, CSS_FLEX_DIRECTION_ROW);\n          childHeight = currentAbsoluteChild.layout.measuredHeight + getMarginAxis(currentAbsoluteChild, CSS_FLEX_DIRECTION_COLUMN);\n        }\n\n        layoutNodeInternal(currentAbsoluteChild, childWidth, childHeight, direction, CSS_MEASURE_MODE_EXACTLY, CSS_MEASURE_MODE_EXACTLY, true, 'abs-layout');\n\n        if (isTrailingPosDefined(currentAbsoluteChild, mainAxis) &&\n            !isLeadingPosDefined(currentAbsoluteChild, mainAxis)) {\n          currentAbsoluteChild.layout[leading[mainAxis]] =\n            node.layout[measuredDim[mainAxis]] -\n            currentAbsoluteChild.layout[measuredDim[mainAxis]] -\n            getTrailingPosition(currentAbsoluteChild, mainAxis);\n        }\n\n        if (isTrailingPosDefined(currentAbsoluteChild, crossAxis) &&\n            !isLeadingPosDefined(currentAbsoluteChild, crossAxis)) {\n          currentAbsoluteChild.layout[leading[crossAxis]] =\n            node.layout[measuredDim[crossAxis]] -\n            currentAbsoluteChild.layout[measuredDim[crossAxis]] -\n            getTrailingPosition(currentAbsoluteChild, crossAxis);\n        }\n      }\n\n      currentAbsoluteChild = currentAbsoluteChild.nextChild;\n    }\n\n    // STEP 11: SETTING TRAILING POSITIONS FOR CHILDREN\n    if (performLayout) {\n      var/*bool*/ needsMainTrailingPos = false;\n      var/*bool*/ needsCrossTrailingPos = false;\n\n      if (mainAxis === CSS_FLEX_DIRECTION_ROW_REVERSE ||\n          mainAxis === CSS_FLEX_DIRECTION_COLUMN_REVERSE) {\n        needsMainTrailingPos = true;\n      }\n\n      if (crossAxis === CSS_FLEX_DIRECTION_ROW_REVERSE ||\n          crossAxis === CSS_FLEX_DIRECTION_COLUMN_REVERSE) {\n        needsCrossTrailingPos = true;\n      }\n\n      // Set trailing position if necessary.\n      if (needsMainTrailingPos || needsCrossTrailingPos) {\n        for (i = 0; i < childCount; ++i) {\n          child = node.children[i];\n\n          if (needsMainTrailingPos) {\n            setTrailingPosition(node, child, mainAxis);\n          }\n\n          if (needsCrossTrailingPos) {\n            setTrailingPosition(node, child, crossAxis);\n          }\n        }\n      }\n    }\n  }\n\n  function canUseCachedMeasurement(\n      isTextNode,\n      availableWidth,\n      availableHeight,\n      marginRow,\n      marginColumn,\n      widthMeasureMode,\n      heightMeasureMode,\n      cachedLayout) {\n\n    var isHeightSame =\n      (cachedLayout.heightMeasureMode == CSS_MEASURE_MODE_UNDEFINED && heightMeasureMode == CSS_MEASURE_MODE_UNDEFINED) ||\n        (cachedLayout.heightMeasureMode == heightMeasureMode && cachedLayout.availableHeight == availableHeight);\n\n    var isWidthSame =\n      (cachedLayout.widthMeasureMode == CSS_MEASURE_MODE_UNDEFINED && widthMeasureMode == CSS_MEASURE_MODE_UNDEFINED) ||\n        (cachedLayout.widthMeasureMode == widthMeasureMode && cachedLayout.availableWidth == availableWidth);\n\n    if (isHeightSame && isWidthSame) {\n      return true;\n    }\n\n    var isHeightValid =\n      (cachedLayout.heightMeasureMode == CSS_MEASURE_MODE_UNDEFINED && heightMeasureMode == CSS_MEASURE_MODE_AT_MOST && cachedLayout.computedHeight <= (availableHeight - marginColumn)) ||\n        (heightMeasureMode == CSS_MEASURE_MODE_EXACTLY && cachedLayout.computedHeight == (availableHeight - marginColumn));\n\n    if (isWidthSame && isHeightValid) {\n      return true;\n    }\n\n    var isWidthValid =\n      (cachedLayout.widthMeasureMode == CSS_MEASURE_MODE_UNDEFINED && widthMeasureMode == CSS_MEASURE_MODE_AT_MOST && cachedLayout.computedWidth <= (availableWidth - marginRow)) ||\n        (widthMeasureMode == CSS_MEASURE_MODE_EXACTLY && cachedLayout.computedWidth == (availableWidth - marginRow));\n\n    if (isHeightSame && isWidthValid) {\n      return true;\n    }\n\n    if (isHeightValid && isWidthValid) {\n      return true;\n    }\n\n    // We know this to be text so we can apply some more specialized heuristics.\n    if (isTextNode) {\n      if (isWidthSame) {\n        if (heightMeasureMode == CSS_MEASURE_MODE_UNDEFINED) {\n          // Width is the same and height is not restricted. Re-use cahced value.\n          return true;\n        }\n\n        if (heightMeasureMode == CSS_MEASURE_MODE_AT_MOST &&\n            cachedLayout.computedHeight < (availableHeight - marginColumn)) {\n          // Width is the same and height restriction is greater than the cached height. Re-use cached value.\n          return true;\n        }\n\n        // Width is the same but height restriction imposes smaller height than previously measured.\n        // Update the cached value to respect the new height restriction.\n        cachedLayout.computedHeight = availableHeight - marginColumn;\n        return true;\n      }\n\n      if (cachedLayout.widthMeasureMode == CSS_MEASURE_MODE_UNDEFINED) {\n        if (widthMeasureMode == CSS_MEASURE_MODE_UNDEFINED ||\n             (widthMeasureMode == CSS_MEASURE_MODE_AT_MOST &&\n              cachedLayout.computedWidth <= (availableWidth - marginRow))) {\n          // Previsouly this text was measured with no width restriction, if width is now restricted\n          // but to a larger value than the previsouly measured width we can re-use the measurement\n          // as we know it will fit.\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  //\n  // This is a wrapper around the layoutNodeImpl function. It determines\n  // whether the layout request is redundant and can be skipped.\n  //\n  // Parameters:\n  //  Input parameters are the same as layoutNodeImpl (see above)\n  //  Return parameter is true if layout was performed, false if skipped\n  //\n  function layoutNodeInternal(node, availableWidth, availableHeight, parentDirection,\n      widthMeasureMode, heightMeasureMode, performLayout, reason) {\n    var layout = node.layout;\n\n    var needToVisitNode = (node.isDirty && layout.generationCount !== gCurrentGenerationCount) ||\n      layout.lastParentDirection !== parentDirection;\n\n    if (needToVisitNode) {\n      // Invalidate the cached results.\n      if (layout.cachedMeasurements !== undefined) {\n        layout.cachedMeasurements = [];\n      }\n      if (layout.cachedLayout !== undefined) {\n        layout.cachedLayout.widthMeasureMode = undefined;\n        layout.cachedLayout.heightMeasureMode = undefined;\n      }\n    }\n\n    var i;\n    var len;\n    var cachedResults;\n\n    // Determine whether the results are already cached. We maintain a separate\n    // cache for layouts and measurements. A layout operation modifies the positions\n    // and dimensions for nodes in the subtree. The algorithm assumes that each node\n    // gets layed out a maximum of one time per tree layout, but multiple measurements\n    // may be required to resolve all of the flex dimensions.\n    // We handle nodes with measure functions specially here because they are the most\n    // expensive to measure, so it's worth avoiding redundant measurements if at all possible.\n    if (isMeasureDefined(node)) {\n      var marginAxisRow = getMarginAxis(node, CSS_FLEX_DIRECTION_ROW);\n      var marginAxisColumn = getMarginAxis(node, CSS_FLEX_DIRECTION_COLUMN);\n\n      // First, try to use the layout cache.\n      if (layout.cachedLayout &&\n          canUseCachedMeasurement(node.isTextNode, availableWidth, availableHeight, marginAxisRow, marginAxisColumn,\n            widthMeasureMode, heightMeasureMode, layout.cachedLayout)) {\n        cachedResults = layout.cachedLayout;\n      } else if (layout.cachedMeasurements) {\n        // Try to use the measurement cache.\n        for (i = 0, len = layout.cachedMeasurements.length; i < len; i++) {\n          if (canUseCachedMeasurement(node.isTextNode, availableWidth, availableHeight, marginAxisRow, marginAxisColumn,\n              widthMeasureMode, heightMeasureMode, layout.cachedMeasurements[i])) {\n            cachedResults = layout.cachedMeasurements[i];\n            break;\n          }\n        }\n      }\n    } else if (performLayout) {\n      if (layout.cachedLayout &&\n          layout.cachedLayout.availableWidth === availableWidth &&\n          layout.cachedLayout.availableHeight === availableHeight &&\n          layout.cachedLayout.widthMeasureMode === widthMeasureMode &&\n          layout.cachedLayout.heightMeasureMode === heightMeasureMode) {\n        cachedResults = layout.cachedLayout;\n      }\n    } else if (layout.cachedMeasurements) {\n      for (i = 0, len = layout.cachedMeasurements.length; i < len; i++) {\n        if (layout.cachedMeasurements[i].availableWidth === availableWidth &&\n            layout.cachedMeasurements[i].availableHeight === availableHeight &&\n            layout.cachedMeasurements[i].widthMeasureMode === widthMeasureMode &&\n            layout.cachedMeasurements[i].heightMeasureMode === heightMeasureMode) {\n          cachedResults = layout.cachedMeasurements[i];\n          break;\n        }\n      }\n    }\n\n    if (!needToVisitNode && cachedResults !== undefined) {\n      layout.measureWidth = cachedResults.computedWidth;\n      layout.measureHeight = cachedResults.computedHeight;\n    } else {\n      layoutNodeImpl(node, availableWidth, availableHeight, parentDirection, widthMeasureMode, heightMeasureMode, performLayout);\n      layout.lastParentDirection = parentDirection;\n\n      if (cachedResults === undefined) {\n        var newCacheEntry;\n        if (performLayout) {\n          // Use the single layout cache entry.\n          if (layout.cachedLayout === undefined) {\n            layout.cachedLayout = {};\n          }\n          newCacheEntry = layout.cachedLayout;\n        } else {\n          // Allocate a new measurement cache entry.\n          if (layout.cachedMeasurements === undefined) {\n            layout.cachedMeasurements = [];\n          }\n          newCacheEntry = {};\n          layout.cachedMeasurements.push(newCacheEntry);\n        }\n\n        newCacheEntry.availableWidth = availableWidth;\n        newCacheEntry.availableHeight = availableHeight;\n        newCacheEntry.widthMeasureMode = widthMeasureMode;\n        newCacheEntry.heightMeasureMode = heightMeasureMode;\n        newCacheEntry.computedWidth = layout.measuredWidth;\n        newCacheEntry.computedHeight = layout.measuredHeight;\n      }\n    }\n\n    if (performLayout) {\n      node.layout.width = node.layout.measuredWidth;\n      node.layout.height = node.layout.measuredHeight;\n      layout.shouldUpdate = true;\n    }\n\n    layout.generationCount = gCurrentGenerationCount;\n    return (needToVisitNode || cachedResults === undefined);\n  }\n\n  function layoutNode(node, availableWidth, availableHeight, parentDirection) {\n    // Increment the generation count. This will force the recursive routine to visit\n    // all dirty nodes at least once. Subsequent visits will be skipped if the input\n    // parameters don't change.\n    gCurrentGenerationCount++;\n\n    var widthMeasureMode = CSS_MEASURE_MODE_UNDEFINED;\n    var heightMeasureMode = CSS_MEASURE_MODE_UNDEFINED;\n\n    if (!isUndefined(availableWidth)) {\n      widthMeasureMode = CSS_MEASURE_MODE_EXACTLY;\n    } else if (isStyleDimDefined(node, CSS_FLEX_DIRECTION_ROW)) {\n      availableWidth = node.style.width + getMarginAxis(node, CSS_FLEX_DIRECTION_ROW);\n      widthMeasureMode = CSS_MEASURE_MODE_EXACTLY;\n    } else if (node.style.maxWidth >= 0.0) {\n      availableWidth = node.style.maxWidth;\n      widthMeasureMode = CSS_MEASURE_MODE_AT_MOST;\n    }\n\n    if (!isUndefined(availableHeight)) {\n      heightMeasureMode = CSS_MEASURE_MODE_EXACTLY;\n    } else if (isStyleDimDefined(node, CSS_FLEX_DIRECTION_COLUMN)) {\n      availableHeight = node.style.height + getMarginAxis(node, CSS_FLEX_DIRECTION_COLUMN);\n      heightMeasureMode = CSS_MEASURE_MODE_EXACTLY;\n    } else if (node.style.maxHeight >= 0.0) {\n      availableHeight = node.style.maxHeight;\n      heightMeasureMode = CSS_MEASURE_MODE_AT_MOST;\n    }\n\n    if (layoutNodeInternal(node, availableWidth, availableHeight, parentDirection, widthMeasureMode, heightMeasureMode, true, 'initial')) {\n      setPosition(node, node.layout.direction);\n    }\n  }\n\n  return {\n    layoutNodeImpl: layoutNodeImpl,\n    computeLayout: layoutNode,\n    fillNodes: fillNodes,\n    canUseCachedMeasurement: canUseCachedMeasurement\n  };\n})();\n\n// This module export is only used for the purposes of unit testing this file. When\n// the library is packaged this file is included within css-layout.js which forms\n// the public API.\nif (typeof exports === 'object') {\n  module.exports = computeLayout;\n}\n\n\n  return function(node) {\n    /*eslint-disable */\n    // disabling ESLint because this code relies on the above include\n    computeLayout.fillNodes(node);\n    computeLayout.computeLayout(node);\n    /*eslint-enable */\n  };\n}));\n"]}